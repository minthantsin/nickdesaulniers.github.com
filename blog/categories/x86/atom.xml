<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: x86 | Nick Desaulniers]]></title>
  <link href="http://nickdesaulniers.github.io/blog/categories/x86/atom.xml" rel="self"/>
  <link href="http://nickdesaulniers.github.io/"/>
  <updated>2016-05-15T19:32:52-07:00</updated>
  <id>http://nickdesaulniers.github.io/</id>
  <author>
    <name><![CDATA[Nick Desaulniers]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What's in a Word?]]></title>
    <link href="http://nickdesaulniers.github.io/blog/2016/05/15/whats-in-a-word/"/>
    <updated>2016-05-15T17:58:00-07:00</updated>
    <id>http://nickdesaulniers.github.io/blog/2016/05/15/whats-in-a-word</id>
    <content type="html"><![CDATA[<p>Recently, there some was some confusion between myself and a coworker over the
definition of a &ldquo;word.&rdquo;  I&rsquo;m currently working on a blog post about data
alignment and figured it would be good to clarify some things now, that we can
refer to later.</p>

<p>Having studied computer engineering and being quite fond of processor design,
when I think of a &ldquo;word,&rdquo; I think of the number of bits wide a processor&rsquo;s
general purpose registers are
(aka <a href="https://en.wikipedia.org/wiki/Word_%28computer_architecture%29#Size_families">word size</a>).
This places hard requirements on the largest representable number and address
space.  A 64 bit processor can represent 2<sup>64</sup>-1 (1.8x10<sup>19</sup>) as the largest
unsigned long integer, and address up to 2<sup>64</sup>-1 (16 EiB) different addresses in
memory.</p>

<p>Further, word size limits the possible combinations of operations the processor
can perform, length of immediate values used, size of binary files, memory
needed to store pointers, and puts pressure on instruction caches.</p>

<p>Word size also has implications on loads and stores based on alignment, as
we&rsquo;ll see in a follow up post.</p>

<p>When I think of 8 bit computers, I think of my first microcontroller: an
Arduino with an Atmel AVR processor.  When I think of 16 bit computers, I think
of my first game console, a Super Nintendo with a Ricoh 5A22.  When I think of
32 bit computers, I think of my first desktop with Intel&rsquo;s Pentium III.  And
when I think of 64 bit computers, I think modern smartphones with ARMv8
instruction sets.  When someone mentions a particular word size, what are the
machines that come to mind for you?</p>

<p>So to me, when someone&rsquo;s talking about a 64b processor, to that machine (and
me) a word is 64b.  When we&rsquo;re referring to a 8b processor, a word is 8b.</p>

<p>Now, some confusion.</p>

<p>Back in my previous blog posts about
<a href="/blog/2014/04/18/lets-write-some-x86-64/">x86-64 assembly</a>,
<a href="/blog/2015/05/25/interpreter-compiler-jit/">JITs</a>, or
<a href="/blog/2016/01/20/debugging-x86-64-assembly-with-lldb-and-dtrace/">debugging</a>,
you might have seen me use instructions that have suffixes of b for byte (8b),
w for word (16b), dw for double word (32b), and qw for quad word (64b) (since
SSE2 there&rsquo;s also double quadwords of 128b).</p>

<p>Wait a minute!  How suddenly does a &ldquo;word&rdquo; refer to 16b on a 64b processor, as
opposed to a 64b &ldquo;word?&rdquo;</p>

<p>In short, historical baggage.  Intel&rsquo;s first hit processor was the
<a href="https://en.wikipedia.org/wiki/Intel_4004">4004</a>,
a 4b processor released in 1971.  It wasn&rsquo;t until 1979 that Intel created the
16b
<a href="https://en.wikipedia.org/wiki/Intel_8086">8086 processor</a>.</p>

<p>The 8086 was created to compete with other 16b processors that beat it to the
market, like the
<a href="https://en.wikipedia.org/wiki/Zilog_Z80">Zilog Z80</a>
(any Gameboy emulator fans out there?  Yes, I know about the Sharp LR35902).
The 8086 was the first design in the
<a href="https://en.wikipedia.org/wiki/X86">x86 family</a>,
and it allowed for the same assembly syntax from the earlier 8008, 8080, and
8085 to be reassembled for it.  The 8086&rsquo;s little brother (8088) would be used
in
<a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer#Open_standards">IBM&rsquo;s PC</a>,
and the rest is history.  x86 would become one of the most successful
ISAs in history.</p>

<p>For backwards compatibility, it seems that both Microsoft&rsquo;s (whose success has
tracked that of x86 since MS-DOS and IBM&rsquo;s PC) and Intel&rsquo;s documentation refers
to words still as being 16b. This allowed 16b PE32+ executables to be run on
32b or even 64b newer versions of Windows, without requiring recompilation of
source or source code modification.</p>

<p>This isn&rsquo;t necessarily wrong to refer to a word based on backwards
compatibility, it&rsquo;s just important to understand the context in which the term
&ldquo;word&rdquo; is being used, and that there might be some confusion if you have a
background with x86 assembly, Windows API programming, or processor design.</p>

<p>So the next time someone asks: why does Intel&rsquo;s documentation commonly refer to
a &ldquo;word&rdquo; as 16b, you can tell them that the x86 and x86-64 ISAs have maintained
the notion of a word being 16b since the first x86 processor, the 8086, which
was a 16b processor.</p>

<p><em>Side Note: for an excellent historical perspective programming early x86
chips, I recommend Michael Abrash&rsquo;s</em>
<a href="http://www.gamedev.net/page/resources/_/technical/graphics-programming-and-theory/graphics-programming-black-book-r1698">Graphics Programming Black Book</a>.
<em>For instance he talks about 8086&rsquo;s little brother, the 8088, being a 16b chip
but only having an 8b bus with which to access memory. This caused a mysterious</em>
<a href="http://downloads.gamedev.net/pdf/gpbb/gpbb4.pdf">&ldquo;cycle eater&rdquo;</a>
<em>to prevent fast access to 16b variables, though they were the processor&rsquo;s
natural size.  Michael also alludes to alignment issues we&rsquo;ll see in a follow
up post.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intro to Debugging x86-64 Assembly]]></title>
    <link href="http://nickdesaulniers.github.io/blog/2016/01/20/debugging-x86-64-assembly-with-lldb-and-dtrace/"/>
    <updated>2016-01-20T20:04:00-08:00</updated>
    <id>http://nickdesaulniers.github.io/blog/2016/01/20/debugging-x86-64-assembly-with-lldb-and-dtrace</id>
    <content type="html"><![CDATA[<p>I&rsquo;m hacking on an assembly project, and wanted to document some of the tricks I
was using for figuring out what was going on.  This post might seem a little
basic for folks who spend all day heads down in gdb or who do this stuff
professionally, but I just wanted to share a quick intro to some tools that
others may find useful.
(<a href="https://pchiusano.github.io/2014-10-11/defensive-writing.html">oh god, I&rsquo;m doing it</a>)</p>

<p>If your coming from gdb to lldb, there&rsquo;s a few differences in commands.  LLDB
has
<a href="http://lldb.llvm.org/lldb-gdb.html">great documentation</a>
on some of the differences. Everything in this post about LLDB is pretty much
there.</p>

<p>The bread and butter commands when working with gdb or lldb are:</p>

<ul>
<li>r (run the program)</li>
<li>s (step in)</li>
<li>n (step over)</li>
<li>finish (step out)</li>
<li>c (continue)</li>
<li>q (quit the program)</li>
</ul>


<p>You can hit enter if you want to run the last command again, which is really
useful if you want to keep stepping over statements repeatedly.</p>

<p>I&rsquo;ve been using LLDB on OSX.  Let&rsquo;s say I want to debug a program I can build,
but is crashing or something:
<code>sh
$ sudo lldb ./asmttpd web_root
</code>
Setting a breakpoint on jump to label:
<code>sh
(lldb) b sys_write
Breakpoint 3: where = asmttpd`sys_write, address = 0x00000000000029ae
</code>
Running the program until breakpoint hit:
<code>``sh
(lldb) r
Process 32236 launched: './asmttpd' (x86_64)
Process 32236 stopped
* thread #1: tid = 0xe69b9, 0x00000000000029ae asmttpd</code>sys_write, queue = &lsquo;com.apple.main-thread&rsquo;, stop reason = breakpoint 3.1</p>

<pre><code>frame #0: 0x00000000000029ae asmttpd`sys_write
</code></pre>

<p>asmttpd`sys_write:
&ndash;>  0x29ae &lt;+0>: pushq  %rdi</p>

<pre><code>0x29af &lt;+1&gt;: pushq  %rsi
0x29b0 &lt;+2&gt;: pushq  %rdx
0x29b1 &lt;+3&gt;: pushq  %r10
</code></pre>

<p><code>
Seeing more of the current stack frame:
</code>sh
(lldb) d
asmttpd`sys_write:
&ndash;>  0x29ae &lt;+0>:  pushq  %rdi</p>

<pre><code>0x29af &lt;+1&gt;:  pushq  %rsi
0x29b0 &lt;+2&gt;:  pushq  %rdx
0x29b1 &lt;+3&gt;:  pushq  %r10
0x29b3 &lt;+5&gt;:  pushq  %r8
0x29b5 &lt;+7&gt;:  pushq  %r9
0x29b7 &lt;+9&gt;:  pushq  %rbx
0x29b8 &lt;+10&gt;: pushq  %rcx
0x29b9 &lt;+11&gt;: movq   %rsi, %rdx
0x29bc &lt;+14&gt;: movq   %rdi, %rsi
0x29bf &lt;+17&gt;: movq   $0x1, %rdi
0x29c6 &lt;+24&gt;: movq   $0x2000004, %rax
0x29cd &lt;+31&gt;: syscall
0x29cf &lt;+33&gt;: popq   %rcx
0x29d0 &lt;+34&gt;: popq   %rbx
0x29d1 &lt;+35&gt;: popq   %r9
0x29d3 &lt;+37&gt;: popq   %r8
0x29 &lt;+39&gt;: popq   %r10
0x29d7 &lt;+41&gt;: popq   %rdx
0x29d8 &lt;+42&gt;: popq   %rsi
0x29d9 &lt;+43&gt;: popq   %rdi
0x29da &lt;+44&gt;: retq
</code></pre>

<p><code>
Getting a back trace (call stack):
</code>sh
(lldb) bt
* thread #1: tid = 0xe69b9, 0x00000000000029ae asmttpd<code>sys_write, queue = 'com.apple.main-thread', stop reason = breakpoint 3.1
  * frame #0: 0x00000000000029ae asmttpd</code>sys_write</p>

<pre><code>frame #1: 0x00000000000021b6 asmttpd`print_line + 16
frame #2: 0x0000000000002ab3 asmttpd`start + 35
frame #3: 0x00007fff9900c5ad libdyld.dylib`start + 1
frame #4: 0x00007fff9900c5ad libdyld.dylib`start + 1
</code></pre>

<p><code>
peeking at the upper stack frame:
</code>sh
(lldb) up
frame #1: 0x00000000000021b6 asmttpd<code>print_line + 16
asmttpd</code>print_line:</p>

<pre><code>0x21b6 &lt;+16&gt;: movabsq $0x30cb, %rdi
0x21c0 &lt;+26&gt;: movq   $0x1, %rsi
0x21c7 &lt;+33&gt;: callq  0x29ae                    ; sys_write
0x21cc &lt;+38&gt;: popq   %rcx
</code></pre>

<p><code>
back down to the breakpoint-halted stack frame:
</code>sh
(lldb) down
frame #0: 0x00000000000029ae asmttpd<code>sys_write
asmttpd</code>sys_write:
&ndash;>  0x29ae &lt;+0>: pushq  %rdi</p>

<pre><code>0x29af &lt;+1&gt;: pushq  %rsi
0x29b0 &lt;+2&gt;: pushq  %rdx
0x29b1 &lt;+3&gt;: pushq  %r10
</code></pre>

<p><code>
dumping the values of registers:
</code>sh
(lldb) register read
General Purpose Registers:</p>

<pre><code>   rax = 0x0000000000002a90  asmttpd`start
   rbx = 0x0000000000000000
   rcx = 0x00007fff5fbffaf8
   rdx = 0x00007fff5fbffa40
   rdi = 0x00000000000030cc  start_text
   rsi = 0x000000000000000f
   rbp = 0x00007fff5fbffa18
   rsp = 0x00007fff5fbff9b8
    r8 = 0x0000000000000000
    r9 = 0x00007fff7b1670c8  atexit_mutex + 24
   r10 = 0x00000000ffffffff
   r11 = 0xffffffff00000000
   r12 = 0x0000000000000000
   r13 = 0x0000000000000000
   r14 = 0x0000000000000000
   r15 = 0x0000000000000000
   rip = 0x00000000000029ae  asmttpd`sys_write
rflags = 0x0000000000000246
    cs = 0x000000000000002b
    fs = 0x0000000000000000
    gs = 0x0000000000000000
</code></pre>

<p><code>
read just one register:
</code>sh
(lldb) register read rdi</p>

<pre><code> rdi = 0x00000000000030cc  start_text
</code></pre>

<p><code>
When you're trying to figure out what system calls are made by some C code,
using dtruss is very helpful.  dtruss is available on OSX and seems to be some
kind of wrapper around DTrace.
</code>sh
$ cat sleep.c</p>

<h1>include &lt;time.h></h1>

<p>int main () {
  struct timespec rqtp = {</p>

<pre><code>2,
0
</code></pre>

<p>  };</p>

<p>  nanosleep(&amp;rqtp, NULL);
}</p>

<p>$ clang sleep.c</p>

<p>$ sudo dtruss ./a.out
&hellip;all kinds of fun stuff
__semwait_signal(0xB03, 0x0, 0x1)    = -1 Err#60
<code>
If you compile with `-g` to emit debug symbols, you can use lldb's disassemble
command to get the equivalent assembly:
</code>sh
$ clang sleep.c -g
$ lldb a.out
(lldb) target create &ldquo;a.out&rdquo;
Current executable set to &lsquo;a.out&rsquo; (x86_64).
(lldb) b main
Breakpoint 1: where = a.out<code>main + 16 at sleep.c:3, address = 0x0000000100000f40
(lldb) r
Process 33213 launched: '/Users/Nicholas/code/assembly/asmttpd/a.out' (x86_64)
Process 33213 stopped
* thread #1: tid = 0xeca04, 0x0000000100000f40 a.out</code>main + 16 at sleep.c:3, queue = &lsquo;com.apple.main-thread&rsquo;, stop reason = breakpoint 1.1</p>

<pre><code>frame #0: 0x0000000100000f40 a.out`main + 16 at sleep.c:3
</code></pre>

<p>   1    #include &lt;time.h>
   2    int main () {
&ndash;> 3      struct timespec rqtp = {
   4        2,
   5        0
   6      };
   7
(lldb) disassemble
a.out`main:</p>

<pre><code>0x100000f30 &lt;+0&gt;:  pushq  %rbp
0x100000f31 &lt;+1&gt;:  movq   %rsp, %rbp
0x100000f34 &lt;+4&gt;:  subq   $0x20, %rsp
0x100000f38 &lt;+8&gt;:  leaq   -0x10(%rbp), %rdi
0x100000f3c &lt;+12&gt;: xorl   %eax, %eax
0x100000f3e &lt;+14&gt;: movl   %eax, %esi
</code></pre>

<p>&ndash;>  0x100000f40 &lt;+16>: movq   0x49(%rip), %rcx</p>

<pre><code>0x100000f47 &lt;+23&gt;: movq   %rcx, -0x10(%rbp)
0x100000f4b &lt;+27&gt;: movq   0x46(%rip), %rcx
0x100000f52 &lt;+34&gt;: movq   %rcx, -0x8(%rbp)
0x100000f56 &lt;+38&gt;: callq  0x100000f68               ; symbol stub for: nanosleep
0x100000f5b &lt;+43&gt;: xorl   %edx, %edx
0x100000f5d &lt;+45&gt;: movl   %eax, -0x14(%rbp)
0x100000f60 &lt;+48&gt;: movl   %edx, %eax
0x100000f62 &lt;+50&gt;: addq   $0x20, %rsp
0x100000f66 &lt;+54&gt;: popq   %rbp
0x100000f67 &lt;+55&gt;: retq
</code></pre>

<p>```</p>

<p>Anyways, I&rsquo;ve been learning some interesting things about OSX that I&rsquo;ll be
sharing soon. If you&rsquo;d like to learn more about x86-64 assembly programming,
you should read my other posts about
<a href="/blog/2014/04/18/lets-write-some-x86-64/">writing x86-64</a>
and a toy
<a href="/blog/2015/05/25/interpreter-compiler-jit/">JIT for Brainfuck</a>
(<a href="https://www.reddit.com/r/programming/comments/377ov9/interpreter_compiler_jit/crkkrz4">the creator of Brainfuck liked it</a>).</p>

<p>I should also do a post on
<a href="http://rr-project.org/">Mozilla&rsquo;s rr</a>,
because it can do amazing things like step backwards.  Another day&hellip;</p>
]]></content>
  </entry>
  
</feed>
