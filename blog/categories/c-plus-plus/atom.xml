<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | Nick Desaulniers]]></title>
  <link href="http://nickdesaulniers.github.io/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://nickdesaulniers.github.io/"/>
  <updated>2016-07-01T23:18:08-07:00</updated>
  <id>http://nickdesaulniers.github.io/</id>
  <author>
    <name><![CDATA[Nick Desaulniers]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Compiling C/C++ Command Line Utilities on Android with Standalone Tools]]></title>
    <link href="http://nickdesaulniers.github.io/blog/2016/07/01/android-cli/"/>
    <updated>2016-07-01T22:42:00-07:00</updated>
    <id>http://nickdesaulniers.github.io/blog/2016/07/01/android-cli</id>
    <content type="html"><![CDATA[<p>Let’s say you want to build a hello world command line application in C or C++
and run it on your Android phone.  How would you go about it?  It’s not super
practical; apps visible and distributable to end users must use the framework
(AFAIK), but for folks looking to get into developing on ARM it’s they likely
have an ARM device in their pocket.</p>

<p>This post is for folks who typically invoke their compiler from the command
line, either explicitly, from build scripts, or other forms of automation.</p>

<p>At
<a href="https://twitter.com/LostOracle/status/697859368226697218">work</a>,
when working on Android, we typically checkout the entire Android source code
(<a href="https://twitter.com/LostOracle/status/702569487531249664">which is huge</a>),
use <code>lunch</code> to configure a ton of environmental variables, then use Makefiles
with lots of includes and special vars.  We don’t want to spend the time and
disk space checking out the Android source code just to have a working cross
compiler.  Luckily, the Android tools team has an excellent utility to grab a
prebuilt cross compiler.</p>

<p>This assumes you’re building from a Linux host.  Android is a distribution of
Linux, which is much easier to target from a Linux host.  At home, I’ll usually
develop on my OSX machine, ssh’d into my headless Linux box. (iTerm2 and tmux
both have exclusive features, but I currently prefer iTerm2.)</p>

<p>The first thing we want to do is fetch the
<a href="https://developer.android.com/ndk/downloads/index.html">Android NDK</a>.
Not the SDK, the NDK.</p>

<p><code>sh
➜  ~ curl -O \
  http://dl.google.com/android/repository/android-ndk-r12b-linux-x86_64.zip
➜  ~ unzip android-ndk-r12b-linux-x86_64.zip
</code></p>

<p>It would be helpful to install adb and fastboot, too.  This might be different
for your distro’s package manager.  Better yet may be to just build from
source.</p>

<p><code>sh
➜  ~ sudo apt-get install android-tools-adb android-tools-fastboot
</code></p>

<p>Now for you Android device that you want to target, you’ll want to know the
ISA.  Let’s say I want to target my Nexus 6P, which has an ARMv8-A ISA (the
first 64b ARM ISA).</p>

<p><code>sh
➜  ~ ./android-ndk-r12b/build/tools/make_standalone_toolchain.py --arch arm64 \
  --install-dir ~/arm
</code></p>

<p>This will create a nice standalone bundle in <code>~/arm</code>.  It will contain our
cross compiler, linker, headers, libs, and sysroot (crt.o and friends).  Most
Android devices are ARMv7-A, so you’d use <code>--arch arm</code>.  See the other
supported architectures for cross compiling under
<a href="https://developer.android.com/ndk/guides/standalone_toolchain.html#itc">table 4</a>.</p>

<p>You might also want to change your install-dir and possible add it to your
<code>$PATH</code>, or set <code>$CC</code> and <code>$CXX</code>.</p>

<p>Now we can compile <code>hello_world.c</code>.</p>

<p>```sh
➜  ~ cat hello_world.c</p>

<h1>include &lt;stdio.h></h1>

<p>int main () {
  puts(&ldquo;hello world&rdquo;);
}</p>

<p>➜  ~ ~/arm/bin/clang -pie hello_world.c
➜  ~ file a.out
a.out: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically
linked, interpreter /system/bin/linker64,
BuildID[sha1]=ecc46648cf2c873253b3b522c0d14b91cf17c70f, not stripped
```</p>

<p><a href="http://stackoverflow.com/a/30547603">Since Android Lollipop</a>,
Android has required that executables be linked as
position independent (<code>-pie</code>) to help provide
<a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization#Android">ASLR</a>.</p>

<p><code>&lt;install-dir&gt;/bin/</code> also has shell scripts with more full featured names like
<code>aarch64-linux-android-clang</code> if you prefer to have clearer named executables
in your $PATH.</p>

<p>Connect your phone, enable remote debugging, and accept the prompt for remote
debugging.</p>

<p><code>sh
➜  ~ adb push a.out /data/local/tmp/.
➜  ~ adb shell "./data/local/tmp/a.out"
hello world
</code></p>

<p>We’ll use this toolchain in a follow post to start writing some ARMv8-A
assembly.  Stay tuned.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Additional C/C++ Tooling]]></title>
    <link href="http://nickdesaulniers.github.io/blog/2015/07/23/additional-c-slash-c-plus-plus-tooling/"/>
    <updated>2015-07-23T21:10:00-07:00</updated>
    <id>http://nickdesaulniers.github.io/blog/2015/07/23/additional-c-slash-c-plus-plus-tooling</id>
    <content type="html"><![CDATA[<p><a href="http://shop.oreilly.com/product/0636920025108.do">21st Century C by Ben Klemens</a>
was a great read. It had a section with an
intro to autotools, git, and gdb.
There are a few other useful tools that came to mind that I&rsquo;ve used when
working with C and C++ codebases. These tools are a great way to start
contributing to
<a href="https://github.com/nickdesaulniers/What-Open-Source-Means-To-Me#what-open-source-means-to-me">Open Source</a>
C &amp; C++ codebases; running these tools on
the code or adding them to the codebases.  A lot of these favor command line,
open source utilities. See how many you are familiar with!</p>

<h2>Build Tools</h2>

<h3>CMake</h3>

<p>The first tool I&rsquo;d like to take a look at is
<a href="http://www.cmake.org/overview/">CMake</a>.  CMake is yet another build tool; I
realize how contentious it is to even discuss one of the many.  From my
experience working with
<a href="https://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html">Emscripten</a>,
we recommend the use of CMake for people
writing portable C/C++ programs.  CMake is able to emit Makefiles for unixes,
project files for Xcode on OSX, and project files for Visual Studio on Windows.
There are also a few other &ldquo;generators&rdquo; that you can use.</p>

<p>I&rsquo;ve been really impressed with CMake&rsquo;s modules for
<a href="http://www.cmake.org/cmake/help/v3.0/command/find_package.html">finding dependencies</a>
and
<a href="http://www.cmake.org/cmake/help/v3.0/module/ExternalProject.html">another for fetching and building external dependencies</a>.
I think
<a href="https://www.youtube.com/watch?v=nshzjMDD79w">C++ needs a package manager badly</a>,
and I think CMake would be a solid foundation for one.</p>

<p>The syntax isn&rsquo;t the greatest, but when I wanted to try to build one of my C++
projects on Windows which I know nothing about developing on, I was able to
install CMake and Visual Studio and get my project building.  If you can build
your code on one platform, it will usually build on the others.</p>

<p>If you&rsquo;re not worried about writing cross platform C/C++, maybe CMake is not
worth the effort, but I find it useful.  I wrestle with the syntax sometimes,
but documentation is not bad and it&rsquo;s something you deal with early on in the
development of a project and hopefully never have to touch again (how I wish
that were true).</p>

<h2>Code Formatters</h2>

<h3>ClangFormat</h3>

<p>Another contentious point of concern amongst developers is code style.
<a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.html">Big companies</a>
with lots of C++ code have
<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Coding_Style#CC_practices">documents</a>
explaining their stylistic choices.  Don&rsquo;t waste another hour of your life
arguing about something that really doesn&rsquo;t matter.
<a href="http://clang.llvm.org/docs/ClangFormat.html">ClangFormat</a> will help you
codify your style and format your code for you to match the style.  Simply
write the code however you want, and run the formatter on it before commiting
it.</p>

<p>It can also emit a .clang-format file that you can commit and clang-format will automatically look for that file and use the rules codified there.</p>

<h2>Linters</h2>

<h3>Flint / Flint++</h3>

<p><a href="https://github.com/facebook/flint">Flint</a> is a C++ linter in use at Facebook.
Since it moved from being
implemented in C++ to D, I&rsquo;ve had issues building it.  I&rsquo;ve had better luck
with a fork that&rsquo;s pure C++ without any of the third party dependencies Flint
originally had, called
<a href="https://github.com/L2Program/FlintPlusPlus">Flint++</a>.  While not quite full-on
static analyzers, both can be used for finding potential issues in your code
ahead of time. Linters can look at individual files in isolation; you don&rsquo;t
have to wait for long recompiles like you would with a static analyzer.</p>

<h2>Static Analyzers</h2>

<h3>Scan-build</h3>

<p><a href="http://clang-analyzer.llvm.org/scan-build.html">Scan-build</a> is a static
analyzer for C and C++ code.  You build your code &ldquo;through&rdquo; it, then use the
sibling tool scan-view to see the results.  Scan-view will emit and open an
html file that shows a list of the errors it detected.  It will insert
hyperlinks into the resulting document that step you through how certain
conditions could lead to a null pointer dereference, for example.  You can also
save and share those html files with others in the project. Static analyzers
will help you catch bugs at compile time before you run the code.</p>

<h2>Runtime Sanitizers</h2>

<h3>ASan and UBSan</h3>

<p>Clang&rsquo;s Address (ASan) and Undefined Behavior (UBSan) sanitizers are simply
compiler flags that can be used to detect errors at runtime.  ASan and UBSan
two of the more popular tools, but there are actually a ton and more being
implemented.  See the list
<a href="http://clang.llvm.org/docs/UsersManual.html#controlling-code-generation">here</a>.
These sanitizers will catch bugs at runtime, so you&rsquo;ll have to run the code
to notice any violations, at variable runtime performance costs per sanitizer.
ASan and TSan (Thread Sanitizer) made it into gcc4.8 and UBSan is in gcc4.9.</p>

<h2>Header Analysis</h2>

<h3>Include What You Use</h3>

<p><a href="https://github.com/include-what-you-use/include-what-you-use">Include What You Use</a>
(IWYU) helps you find unused or unnecessary <code>#include</code> preprocessor directives.
It should be obvious how this can help improve compile times. IWYU can also
help cut down on recompiles by recommending forward declarations under certain
conditions.
I look forward to the C++ module proposal being adopted, but until then this
tool can help you spot cruft that can be removed.</p>

<h2>Rapid Recompiles</h2>

<h3>ccache</h3>

<p><a href="https://ccache.samba.org/">ccache</a> greatly improves recompile times by caching
the results of parts of the compilation process.
<a href="https://github.com/nickdesaulniers/dotfiles/blob/49984b3e82022e5ce82e778fc8ce990f8e1e554a/.mozconfig#L1">I use when building Firefox</a>,
and it saves a great deal of time.</p>

<h3>distcc</h3>

<p><a href="https://github.com/distcc/distcc">distcc</a> is a distributed build system.
<a href="http://blog.dholbert.org/">Some folks at Mozilla</a> speed up their Firefox builds with it.</p>

<h2>Memory Leak Detectors</h2>

<h3>Valgrind</h3>

<p><a href="http://valgrind.org/info/about.html">Valgrind</a> has a
<a href="http://valgrind.org/info/about.html">suite of tools</a>, my
favorite being memcheck for finding memory leaks. Unfortunately, it doesn&rsquo;t
seem to work on OSX since 10.10.
<a href="https://code.google.com/p/address-sanitizer/wiki/ComparisonOfMemoryTools">This page</a>
referring to ASan seems to indicate that it can do everything Valgrind&rsquo;s
Memcheck can, at less of a runtime performance cost, but I&rsquo;m not sure how true
this is exactly.</p>

<h3>leaks</h3>

<p>A much more primitive tool for finding leaks from the command line, BSD&rsquo;s have
<code>leaks</code>.</p>

<p><code>bash
MallocStackLogging=1 ./a.out
leaks a.out
...
</code></p>

<h2>Profilers</h2>

<h3>Perf</h3>

<p>Perf, and
<a href="http://www.brendangregg.com/flamegraphs.html">Brendan Gregg&rsquo;s tools for emitting SVG flamegraphs</a>
from the output
are helpful for finding where time is spent in a program. In fact, there are
numerous perfomance analysis tools that are Linux specific.  My recommendation
is spend some time on <a href="http://www.brendangregg.com/linuxperf.html">Brendan Gregg&rsquo;s blog</a>.</p>

<h3>DTrace</h3>

<p>OSX doesn&rsquo;t have the same tooling as Linux, but DTrace was ported to it.  I&rsquo;ve
used it to find sampling profiles of my code before. Again,
<a href="http://www.brendangregg.com/dtrace.html">Brendan Gregg&rsquo;s blog</a> is a good
resource; there are some fantastic DTrace one liners.</p>

<h2>Debuggers</h2>

<h3>lldb</h3>

<p>lldb is analogous to gdb.  I can&rsquo;t say I have enough experience with LLDB and GDB to note the difference between the two, but LLDB did show the relative statements forward and back from the current statement by default.  I&rsquo;m informed by my friends/mortal enemies using emacs that this is less of an issue when using emacs/gdb in combination.</p>

<h2>Fuzzers</h2>

<h3>American Fuzzy Lop</h3>

<p><a href="http://lcamtuf.coredump.cx/afl/">American Fuzzy Lop</a> (AFL) is a neat program
that performs fuzzing on programs
that take inputs from files and repeatedly runs the program, modifies the
input trying to get full code coverage, and tries to find crashes.  It&rsquo;s been
getting lots of attention lately, and while I haven&rsquo;t used it myself yet, it
seems like a very powerful tool. Mozilla employs the use of fuzzers on their
JavaScript engine, for instance (not AFL, but
<a href="http://www.squarefree.com/2007/08/02/introducing-jsfunfuzz/">one developed in house</a>).</p>

<h2>Disassemblers</h2>

<h3>gobjdump</h3>

<p>If you really need to make sure the higher level code you&rsquo;re writing is getting
translated into the assembly your expecting, <code>gobjdump -S</code> will intermix the
emitted binary&rsquo;s disassembled assembly and the source code.  This was used
extensively while developing <a href="/blog/2015/05/25/interpreter-compiler-jit/">my Brainfuck JIT</a>.</p>

<h2>Conclusion</h2>

<p>Hopefully you learned of some useful tools that you should know about when
working with C or C++.  What did I miss?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rust: Pattern Matching and the Option Type]]></title>
    <link href="http://nickdesaulniers.github.io/blog/2013/05/07/rust-pattern-matching-and-the-option-type/"/>
    <updated>2013-05-07T18:41:00-07:00</updated>
    <id>http://nickdesaulniers.github.io/blog/2013/05/07/rust-pattern-matching-and-the-option-type</id>
    <content type="html"><![CDATA[<p>The other day I was thinking about the function for performing dynamic memory
allocation in the C standard library, malloc. From the manual pages,
<code>If successful, the malloc() function returns a pointer to allocated memory.
If there is an error, it
returns a NULL pointer and sets errno to ENOMEM.</code> One of the most common errors
when using malloc is not checking for allocation failure.  The allocation is not
guaranteed to succeed and trying to use a NULL reference can lead to program
crashes.</p>

<p>So a common pattern we&rsquo;ll see is:</p>

<p><code>c C
int* nums = (int*) malloc(sizeof(int));
if (nums == NULL) {
  // handle error
} else {
  *nums = 7;
  // operate on nums
  free(nums);
  nums = NULL;
}
</code></p>

<p>Here we allocated space for an integer, cast the <code>void*</code> returned from malloc
to an <code>int*</code>, compared it against the <code>NULL</code> pointer, then freed the allocated
memory and removed the reference.</p>

<p>One of the big problems with the null pointer has to do with
safely dereferencing it.  In C, dereferencing the null pointer is undefined
and usually leads to a segfault and program crash.</p>

<p>It can be so unsafe to work with null pointers that
C. A. R. Hoare refers to them as his billion-dollar mistake:</p>

<p><blockquote><p>I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn&rsquo;t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</p><footer><strong>C.A.R. Hoare</strong> <cite>InfoQ <a href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare</a> Null References: The Billion Dollar Mistake</cite></footer></blockquote></p>

<p>So how do we represent the value of nothing?  With an integer, for example, your
first instinct might be to use 0 to refer to no value.  But 0 <em>is</em> a value, so
how do we represent the range of integer values but also whether there is a
value or not?</p>

<p>Rust, a systems programming language with a focus on safety and concurrency,
does not have the concept of a null pointer.  Instead, it has a different
construct to represent the absence of value, a whole other structure called an
<a href="http://static.rust-lang.org/doc/core/option.html">Option<T></a>.  It is an
<a href="http://static.rust-lang.org/doc/core/option.html#enum-option">enumerated type</a> that can
either be None (no value) or Some(T) (a specialization of type T).</p>

<p>So what the heck is an option type and how do we use it?  The option type is
a polymorphic type (generic type that can be specialized) that encapsulates
either an empty constructor or the constructor of the original data type.  Let&rsquo;s
take a trip down the rabbit hole to see how we use one.  First, let&rsquo;s look at
some C++ code, and then translate it to Rust.</p>

<p>```c++ option.cpp</p>

<h1>include <iostream> // cout, endl</h1>

<h1>include &lt;stdlib.h> // rand</h1>

<h1>include &lt;time.h> // time</h1>

<p>using namespace std;</p>

<p>// If there is a &lsquo;random error&rsquo; returns NULL
const int* const may_return_null () {
  srand(time(NULL));
  return rand() % 2 == 1 ? new int(666) : NULL;
}</p>

<p>int main () {
  // if else
  const int* const x = may_return_null();
  if (x) {</p>

<pre><code>// switch
switch (*x) {
  case 777: cout &lt;&lt; "Lucky Sevens"        &lt;&lt; endl; break;
  case 666: cout &lt;&lt; "Number of the Beast" &lt;&lt; endl; break;
  case 42: cout  &lt;&lt; "Meaning of Life"     &lt;&lt; endl; break;
  default: cout  &lt;&lt; "Nothing special"     &lt;&lt; endl; break;
}
</code></pre>

<p>  } else {</p>

<pre><code>cout &lt;&lt; "No value" &lt;&lt; endl;
</code></pre>

<p>  }</p>

<p>  // single if
  if (*x == 666) {</p>

<pre><code>cout &lt;&lt; "Did I mention that Iron Maiden is my favorite band?" &lt;&lt; endl;
</code></pre>

<p>  }
}</p>

<p>```</p>

<p>Let&rsquo;s step through this program line by line, starting in main.</p>

<p><code>c++ Line 14
const int* const x = may_return_null();
</code></p>

<p>Here we&rsquo;re calling a function that may return null, just like malloc!</p>

<p><code>c++ Lines 8-9
srand(time(NULL));
return rand() % 2 == 1 ? new int(666) : NULL;
</code></p>

<p>In the body of <code>may_return_null</code> we seed the random number generator, generate a random number, mod it by 2
(so it can either be 0 or 1, 50-50 chance, hopefully), then either return a
pointer pointing to memory allocated on the heap or the null pointer.  We also use the succinct
ternary operator, which gives us the power of a conditional statement in the
form of a concise expression.</p>

<p><code>c++ Line 15
if (x) {
</code></p>

<p>We check if the pointer is valid, that is that it is safe to use, as <code>NULL</code> is
falsy in a C++ conditional.  If it is, then we can safely dereference it.  Let&rsquo;s
switch on the (dereferenced) value.  Notice how we need to break to explicitly
prevent fall through, though
<a href="http://books.google.com/books?id=4vm2xK3yn34C&amp;pg=PA37&amp;lpg=PA38&amp;dq=expert+c+fallthrough&amp;source=bl&amp;ots=Ho98ZhXF9X&amp;sig=PebysT8-3zA_9B2aRkuvnz4mCmY&amp;hl=en&amp;sa=X&amp;ei=j8CJUdeWMerJiwLQmICoDw&amp;ved=0CC4Q6AEwAA#v=onepage&amp;q=expert%20c%20fallthrough&amp;f=false">97% of the time that&rsquo;s what you intend</a>.</p>

<p><code>c++ Lines 17-22
switch (*x) {
  case 777: cout &lt;&lt; "Lucky Sevens"        &lt;&lt; endl; break;
  case 666: cout &lt;&lt; "Number of the Beast" &lt;&lt; endl; break;
  case 42: cout  &lt;&lt; "Meaning of Life"     &lt;&lt; endl; break;
  default: cout  &lt;&lt; "Nothing special"     &lt;&lt; endl; break;
}
</code></p>

<p>If the pointer was null, the else branch of the conditional would execute
printing a different result.</p>

<p><code>c++ Line 24
cout &lt;&lt; "No value" &lt;&lt; endl;
</code></p>

<p>Finally in we check the value pointed to.  Did I forget something here?  Save
that thought, we&rsquo;ll come back to it.</p>

<p><code>c++ Lines 28-30
if (*x == 666) {
  cout &lt;&lt; "Did I mention that Iron Maiden is my favorite band?" &lt;&lt; endl;
}
</code></p>

<p>Let&rsquo;s see my rough translation of this program into Rust.</p>

<p>```rust option.rs
use core::rand;</p>

<p>fn may_return_none () &ndash;> Option<int> {
  if rand::Rng().next() % 2 == 1 { Some(666) } else { None }
}</p>

<p>fn main () {
  let x: Option<int> = may_return_none();</p>

<p>  io::println(match x {</p>

<pre><code>Some(777) =&gt; "Lucky Sevens",
Some(666) =&gt; "Number of the Beast",
Some(422) =&gt; "Meaning of Life",
Some(_) =&gt; "Nothing special",
None =&gt; "No value"
</code></pre>

<p>  });</p>

<p>  match x {</p>

<pre><code>Some(666) =&gt; {
  io::println("Did I mention that Iron Maiden is my favorite Band?")
},
_ =&gt; {}
</code></pre>

<p>  };
}
```</p>

<p>Both programs, when compiled <em>should</em> randomly print either:</p>

<p><code>
No Value
// or
Number of the Beast
Did I mention that Iron Maiden is my favorite Band?
</code></p>

<p>Now let&rsquo;s walk through the Rust code, starting at main and compare it to the
equivalent C++ code.</p>

<p><code>rust option.rs Line 8
let x: Option&lt;int&gt; = may_return_none();
</code>
<code>c++ option.cpp Line 14
const int* const x = may_return_null();
</code></p>

<p>I read this Rust code as &lsquo;let x be type Option,
specialized to type int initialized
to the return value of may_return_none.&rsquo;  I read the C++ as &lsquo;x is a const pointer
to a const integer initialized to the return value of may_return_none.&rsquo;  It&rsquo;s
important to note that values and pointers in Rust default to being immutable,
where as in c++ they default to being mutable, which is why we need to be
explicit about their const'ness.  In Rust, we could declare x as being explicitly
mutable: <code>let mut x: ... = ...;</code>.  In both, we can also leave the explicit types
to be inferred by the compiler.</p>

<p><code>rust option.rs Line 4
if rand::Rng().next() % 2 == 1 { Some(666) } else { None }
</code>
<code>c++ option.cpp Lines 8-9
srand(time(NULL));
return rand() % 2 == 1 ? new int(666) : NULL;
</code></p>

<p>Now for the body of <code>may_return_none</code>.  Rust does not have a ternary operator,
so a single line <code>if {} else {}</code> block will have to do.  We also don&rsquo;t need
parentheses around the predicate in the conditional statement.  If we add them,
no harm is done, as we&rsquo;d just be being redundant about order of operations.
There
are no semicolons in this expression, nor a return statement in this function.
Rust will return the last expression in a function or method if the semicolon is
left off.  Also there is no such thing as a conditional statement, only
conditional expressions; the if is itself something that can be evaluated and
assigned to a variable!  We see this later in the code where we pass the evaluation
of a match expression directly into a call of <code>io::println</code>.
Rust returns the evaluation of the if expression,
which is the evaluation of the branch&rsquo;s block specified by the predicate,
which will randomly be one of the two enumerated types of <code>Option&lt;int&gt;</code>, either
an encapsulation of a int whose literal value is <code>666</code>, <code>Some&lt;666&gt;</code>, or
the representation of no value, <code>None</code>.  I believe the RNG code has changed in 0.7,
this code was written in 0.6.</p>

<p>In Rust, to get the value out of an option type, we pattern match on it.  Pattern
matching is something I became familiar with through the
<a href="http://learnyouahaskell.com/syntax-in-functions#pattern-matching">Haskell</a> programming language.  Pattern
matching is a powerful language construct that can entirely replace conditionals.
In fact, the one line if expression could have been written using a match
expression:</p>

<p><code>rust
if rand::Rng().next() % 2 == 1 { Some(666) } else { None }
// or
match rand::Rng().next() % 2 { 1 =&gt; Some(666), _ =&gt; None }
</code></p>

<p>The basic design pattern
for accessing the value of an option type in Rust looks like:</p>

<p><code>rust
match x { // x: Option&lt;T&gt;
  Some(y) =&gt; { *y },
  None =&gt; {}
}
</code></p>

<p>The curly braces are optional for one liners (no block needed).
Pattern matches have to be exhaustive.  That means I have to exhaust all
possibilities for what the deconstructed value could be.  You can use a branch
that looks like:</p>

<p><code>rust
_ =&gt; 'everything else'
</code></p>

<p>to catch everything else.  The underscore here means &ldquo;every other possible case.&rdquo;
So by having to use a match expression (also not a
statement, as opposed to C++&rsquo;s switch statement), which itself must be exhaustive,
Rust forces us to handle the case where the optional type is None!  This will
help us again in the future.
We also don&rsquo;t need parentheses around the predicate for the match expression, which
in this case is just a single variable, <code>x</code>.</p>

<p>In the value
<code>Some(_)</code>, the underscore has an additional meaning here that we would not use a
variable in the corresponding arm&rsquo;s block.  If we declared it as <code>Some(y)</code> we would get the warning:</p>

<p><code>``
option.rs:14:9: 14:11 warning: unused variable:</code>y`
option.rs:14     Some(y) => &ldquo;Nothing special&rdquo;,</p>

<pre><code>                  ^~
</code></pre>

<p>```</p>

<p>I hope back in my C++ code you spotted the fatal flaw.  On line 28, I just
dereferenced a raw pointer without checking its validity.  This is a violation
of memory safety.</p>

<p><code>c++ option.cpp Line 28
if (*x == 666) {
</code></p>

<p>When running the C++ code, instead of seeing <code>No value</code> printed to stdout in the
case of no value, a segfault occurs.</p>

<p><code>
No value
[1]    80265 segmentation fault  ./option
</code></p>

<p>What I should have done is something more like:</p>

<p><code>c++ Line 28 corrected
if (x &amp;&amp; *x == 666) {
</code></p>

<p>But, the C++ compiler let me get away with not handling the case where the
pointer was invalid (even if doing nothing in the case of &ldquo;handling&rdquo; it).  By
leaving out the check for a valid pointer, I have instructed the machine to
behave the same or follow the same code path with and without a reference to a
valid memory location.  Let&rsquo;s see what happens when I don&rsquo;t handle the None case
by deleting line 15 or option.rs, <code>None =&gt; "No value"</code>:</p>

<p><code>
option.rs:10:14: 16:3 error: non-exhaustive patterns: None not covered
option.rs:10   io::println(match x {
option.rs:11     Some(777) =&gt; "Lucky Sevens",
option.rs:12     Some(666) =&gt; "Number of the Beast",
option.rs:13     Some(42) =&gt; "Meaning of Life",
option.rs:14     Some(_) =&gt; "Nothing special"
</code></p>

<p>Not only did the compiler prevent me from generating an executable, it told me
that a pattern was not exhaustive, explicitly which one, and what case that was
not covered.</p>

<p>Coming back to encoding a lack of value for an int, we had left off that 0 <em>is</em>
a valid value.  For instance, how should we represent any other integer divided
by 0, as an integer?
Signed integers use a single bit to store whether
their value is positive or negative, the tradeoff being the signed integers
represent up to one less power of two than unsigned integers.  Maybe we could use an
additional bit to represent valid or invalid, but this would again cost us in
terms of representable values.
The IEEE 754 floating point representation has encodings for <a href="https://en.wikipedia.org/wiki/IEEE_floating_point#Formats">plus and minus
Infinity, plus and minus 0, and two kinds of NaN</a>.
To solve the validity problem, we can use enumerated types, which in Rust occur
as specializations of the Option type.  It&rsquo;s up to the compiler to implement
either additional information for the type, or use raw null pointers.  And to
get the value back out of the Option type, we <em>must</em> handle the case where there
is no valid value.</p>

<p>The key takeaways that I wish to convey are:</p>

<ol>
<li>In C and C++, I can use NULL to refer to a pointer that has no value.</li>
<li>A C/C++ compiler, such as clang, will allow me to compile code that violates
memory safety, such as dereferencing NULL pointers.</li>
<li>Rust instead uses Option types, an enumeration of a specialized type or None.</li>
<li>Rust forces me to use a match statement to access the possible value of an
Option type.</li>
<li>Pattern matching in Rust must be exhaustive.</li>
<li>The Rust compiler, rustc, forces me to handle the case where the pointer has
no value, whereas the C++ compiler, clang++, did not.</li>
<li>All conditional and switch statements can be replaced with pattern matching.</li>
</ol>

]]></content>
  </entry>
  
</feed>
